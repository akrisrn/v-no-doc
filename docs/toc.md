# 内容目录

@tags: 语法/标记
@updated: 1609946515000, 1610010298000
@creator: AkrISrn
@updater: AkrISrn
@commit: 5bb21c7

你可以使用单独占据一行的 `[toc]` 标记（不区分大小写）在你指定的位置为页面添加内容目录（Table of contents）。如果一个页面有多个 `[toc]` 标记，只有第一个会生效，其它都会被剔除。

v-no 会在页面宽度允许的情况下，自动将过长的 TOC 尽可能均匀地分成两到三组并排展示。

## 分组算法

这个算法的时间复杂度大概在 `O(n log n)`。

**步骤简述：**

1. 先为标题总数大于 7 的 TOC 预分配两组、大于 11 的预分配三组。
1. 根据预分配的组数计算平均标题个数，将它作为第一轮分组时的每组最大容量。
1. 依序将最外层的 `<li>` 标签（移动的最小单元）推入预分配的组中，在当前组的标题总数即将超过最大容量时进入下一组。
1. 直到预分配的所有组都被填满：
    - 如果所有元素都在组内，则分组完成。
    - 如果还有剩余元素，将第二组第一个元素推进第一组，并将第一组的总数作为新的最大容量，从第二组第二个元素开始，重新分配第一组之后的其它组。

**举个例子：**

首先将 TOC 描述为由每个最外层 `<li>` 标签所包含的标题个数组成的数组。

```js
[3, 4, 1, 9, 2, 7, 8, 6, 5]
```

这个数组的总和为 45，为它预分配三组，每组容量为 15。

- 第一轮分组（容量：15）：
    1. `[3, 4, 1]` = 8，+ 9 = 17，超出 15，进入下一组。
    1. `[9, 2]` = 11
    1. `[7, 8]` = 15，已经分完三组了，但是还剩 `[6, 5]` 没有分，扩增容量进入下一轮。
- 第二轮分组（容量：17）：
    1. `[3, 4, 1, 9]` = 17
    1. `[2, 7, 8]` = 17
    1. `[6, 5]` = 11，分组完成。

需要注意的是，预分配的三组并不会总是被填充。只要移除示例数组最后两项，它就会被分成 17 + 17 的两组。

[](/api/index.md "#") 有着文档最长的 TOC（两百多个 `<li>`），我很满意它在这个算法下的呈现效果。

当然，如果你有更好的想法，欢迎改进它！它位于 [updateHeading](https://github.com/akrisrn/v-no/blob/master/src/ts/async/update.ts) 函数的最后一部分。
